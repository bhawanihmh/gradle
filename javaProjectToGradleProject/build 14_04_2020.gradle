/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.3/userguide/tutorial_java_projects.html
 */


plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Apply the application plugin to add support for building a CLI application.
    id 'application'
    
    id 'jacoco'
}

jacoco {
    //toolVersion = "0.8.5"
    //reportsDir = file("$buildDir/customJacocoReportDir")
    applyTo run
}
/*
jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.destination file("${buildDir}/jacocoHtml")
    }
}*/
//apply plugin: 'jacoco'

/*
jacoco {
    toolVersion = '0.8.5'
    applyTo junitPlatformTest
}*/
/*
sourceSets {
  main {
    //if you truly want to override the defaults:
    output.resourcesDir = file('src')
    // Compiled Java classes should use this directory
    java.outputDir = file('build/classes')
  }
}*/
/*
n’t have to. There are several options for customization, as you’ll see next.

Customizing file and directory locations
Imagine you have a legacy project that uses an src directory for the production 
code and test for the test code. The conventional directory structure won’t work, 
so you need to tell Gradle where to find the source files. You do that via source set configuration.

Each source set defines where its source code resides, along with the resources 
and the output directory for the class files.
sourceSets {
    main {
         java {
            srcDirs = ['src']
         }
    }

    test {
        java {
            srcDirs = ['test']
        }
    }
}
Now Gradle will only search directly in src and test for the respective source code. 
What if you don’t want to override the convention, but simply want to add an extra source 
directory, perhaps one that contains some third-party source code you want to keep separate? 
sourceSets {
    main {
        java {
            srcDir 'thirdParty/src/main/java'
        }
    }
}
*/
sourceSets {
    main {
         java {
            srcDirs = ['src']
         }
    }

    test {
        java {
            srcDirs = ['test']
        }
    }
}

/*
sourceCompatibility
Defines which language version of Java your source files should be treated as.

targetCompatibility
Defines the minimum JVM version your code should run on, i.e. it determines the 
version of byte code the compiler generates.
*/
repositories {
	
	// If you want to use a (flat) filesystem directory as a repository
	flatDir {
		dirs 'libs'
		//dirs 'lib1', 'lib2'
	}
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    //jcenter()
}

dependencies {
	implementation fileTree(dir: 'libs', include: '*.jar')
	//runtime fileTree(dir: 'libs', include: '*.jar')
	testImplementation fileTree(dir: 'libs', include: '*.jar')
	testRuntimeOnly fileTree(dir: 'libs', include: '*.jar')
    // This dependency is used by the application.
    //implementation 'com.google.guava:guava:28.2-jre'

    // Use JUnit test framework
    //testImplementation 'junit:junit:4.12'
    //testImplementation 'org.junit.jupiter:junit-jupiter-api:5.3.1'
    //testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.3.1'
}


application {
    // Define the main class for the application.
    mainClassName = 'com.adcb.xyz.App'
    
}

version = '1.0.0'
/*jar {
    manifest {
        attributes('Implementation-Title': project.name,
                   'Implementation-Version': project.version)
    }
}*/
//create a single Jar with all dependencies
task fatJar(type: Jar) {
	manifest {
        attributes 'Implementation-Title': 'Gradle Jar File Example for ADCB',  
        	'Implementation-Version': version,
        	'Main-Class': 'com.adcb.xyz.App'
    }
   	archiveBaseName = project.name// + '-all'
   	
   	//from fileTree('src') {
      //  include '**/*/.class'
    //}
    //from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    
    into('lib') {
        from 'libs'
    }
    with jar // The important part is with jar. Without it, the classes of this project are not included.
}

/*
//The important part is with jar. Without it, the classes of this project are not included.
task fatJar(type: Jar) {
    classifier = 'all'
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}

*/
/*

test {
    useJUnitPlatform {
        includeTags 'fast'
        excludeTags 'slow'
    }
}

*/
task listJarsCompile  {
    configurations.compile.each { File file -> println file.name }
}
task listJarsRuntime  {
    configurations.runtime.each { File file -> println file.name }
}
/*
jacocoTestReport {
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['**Main*'])
        })
    }
}

junitPlatformTest {
    jacoco {
        destinationFile = file("${buildDir}/jacoco/test.exec")
    }
}
*/



test {
    //useJUnitPlatform()
    jacoco {
        destinationFile = file("$buildDir/jacoco/jacocoTest.exec")
        classDumpDir = file("$buildDir/jacoco/classpathdumps")
    }
}

task applicationCodeCoverageReport(type:JacocoReport) {
    //executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")
    //executionData fileTree(".").include("**/build/jacoco/*.exec")
    //executionData fileTree(${buildDir}).include("/jacoco/*.exec")
    executionData run
    sourceSets sourceSets.main
    reports {
        xml.enabled true
       // xml.destination "**/build/reports/jacoco/report.xml"
        html.enabled true
        csv.enabled false
    }
}

applicationCodeCoverageReport.dependsOn {
    subprojects*.test
}

